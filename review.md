# 자바 기초
### Hello World 출력
    public class 'MainClass' {
      public static void main(String[] args) {
        System.out.print("Hello World!!");
      }
    }
### 변수
변수의 타입
|변수의 타입|설명|
|:---:|:---|
|'int'|정수를 저장하는 타입(기본형)|
|'long'|20억이 넘을 때 사용|
|'float'|실수를 저장하는 타입 - 7자리|
|'double'|실수를 저장하는 타입(기본형) - 15자리|
|'char'|문자를 저장하기 위한 타입|
|'String'|문자열을 저장하기 위한 타입|  
- 변수(variable) : 하나의 값을 저장하기 위한 공간
- 상수(constant) : 값을 한번만 저장할 수 있는 공간(변경 불가능), 일반적으로 대문자로 표기
- 리터럴(literal) : 그 자체로 값을 의미하는 것(수학에서의 상수)
### 리터럴 타입의 접미사
변수에 타입이 있는 것처럼 리터럴에도 타입이 구분되어 있다.
|종류|리터럴|접미사|
|:---:|---|---|
|논리형|false, true|없음|
|정수형|123, 0b0101, 077, 0xFF, 100L|L|
|실수형|3.14, 3.0e8, 1.4f, 0x1.0p-1|f,d|
|문자형|'A', '1','\n'|없음|
|문자열|"ABC", "123", "!", "true없음|
  
정수형의 경우 long타입의 리터럴에는 접미사 'l', 'L'을 붙이고, byte, short, int 타입은 접미사가 없고 모두 int타입의 리터럴이다.  
접두사를 통해 2, 8, 16진수를 표현할 수 있다. 16진수는 리터럴 앞에 '0x', '0X'를 붙이고, 8진수는 '0', 2진수는 '0b'를 붙인다.  
또한 정수형 리터럴은 숫자 중간에 구분자를 넣어 숫자를 편하게 읽을 수 있다. 100_000_000_000L = 100000000000L  
실수형 리터럴은 float타입은 'f'를 double타입은 'd'를 붙인다. 정수형과 마찬가지로 기본형인 double의 'd'는 생략 가능하는 float타입은 생략 불가능하다.  
### 기본형(primitive type)과 참조형(reference type)
기본형 변수는 실제 값(data)을 저장한다. 반면 참조형 변수는 어떤 값이 저장되어 있는 주소(memory address)를 저장한다. 참조형 변수간에는 연산을 할 수 없다.  

printf()의 지시자  
|지시자|설명|
|---|---|
|%d|10진수(decimal)|
|%x|16진수(hexa-decimal)|
|%f|소수(floating)|
|%c|문자(character)|
|%s|문자열(string)|  
  
### 입력받기  
    import java.util.Scanner; // Scanner class import
    Scanner scanner = new Scanner(System.in); // 객체 생성
    String input = scanner.nextLine(); // 문자열로 입력받기
    int num1 = Integer.parseInt(input); // 문자열을 int타입으로 변환
    int num2 = scanner.nextInt(); // 정수로 입력받기  
### 연산자의 종류
|종류|연산자|설명|
|:---:|:---:|---|
|산술 연산자| + - * / % << >>|사칙 연산과 나머지 연산(%)|
|비교 연산자|> < >= <= == != |크고 작음과 같고 다름을 비교|
|논리 연산자|&& ! & ^ ~ |'그리고(AND)'와 '또는(OR)'으로 조건을 연결|
|대입 연산자|=|우변의 값을 좌변에 저장|
|기 타|(type) ?: instanceof|항변환 연산자, 삼항 연산자, instanceof연산자|  
### 연산자의 우선순위 와 결합규칙
1. 산술 > 비교 > 논리 > 대입
2. 단항 > 이항 > 삼항
3. 단항 연산자와 대입 연사자를 제외한 모든 연산자는 왼쪽에서 오른쪽으로 진행  
### 증감 연산자
증가 연산자(++)는 피연산자의 값을 1 증가시키고, 감소 연산자(--)는 피연산자의 값을 1 감소시킨다.  
|타입|설명|사용예|
|:---:|---|:---:|
|전위형|값이 참조되기 전에 증가시킨다.|j = ++i;|
|후위형|값이 참조된 후에 증가시킨다.|j = i++;|  
    j = ++i; // 전위형 -> ++i; j = i;
    j = i++; // 후위형 -> j = i; i++;  
## 조건문과 반복문
### 조건문
if문의 기본형식

    if (조건식) {
        //조건식이 참(true)일 때 수행될 문장들을 적는다.
    }
    
    if (조건식) {
        // 참인 경우 수행될 코드
    } else {
        // 거짓인 경우 수행될 코드
    }
    
    if (조건식1) {
        // 조건식1이 참인 경우 수행될 코드
    } else if (조건식2)
        // 조건식1은 거짓이고 조건식2가 참인 경우 수행될 코드
        // else if는 여러개 작성할 수 있다.
    } else {
        // 모든 조건식이 거짓인 경우 수행될 
    }

if문에서 수행할 동작이 한 문장이라면 블록({})을 생략할 수 있다. ex) if (true) System.out.println("True");  
또한 if문 안에 if문을 넣어 중첩해서 사용할 수도 있다.  

switch문의 기본형식  

    switch (조건식) {
        case 값1 :
                // 조건식의 결과가 값1과 같을 경우 수행될 문장들
                // ...
                break;
        case 값2 :
                // 조건식의 결과가 값2와 같은 경우 수행될 문장들
                // ...
                break;
        case 값3 :
        case 값4 :
        case 값5 : case 값6 :
                // 조건식의 결과가 값3,4,5,6과 같을 경우 수행될 문장들
        // ...
        default :
                // 조건식의 결과와 일치하는 case문이 없을 때 수행될 문장들
                // ...
    }
switch문의 제약조건  
1. switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
2. case문의 값은 정수 상수(문자 포함), 문자열만 가능하며, 중복되지 않아야 한다.  

## 객체지향 프로그래밍
### 객체지향 언어
기존 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 형태  
새로운 규칙을 통해 코드 간에 서로 **관계**를 맺어 줌으로써 유기적인 프로그램을 구성하는 것이 가능해졌다.  
절차형 언어와 구분된 주요 특징으로는
1. 코드의 재사용성이 높다. -> 새로운 코드를 작성할 때 기존의 코드를 이용할 수 있다.
2. 코드의 관리가 용이하다. -> 코드간의 관계를 이용하여 쉽게 코드를 변경할 수 있다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다. -> 제어자와 메소드를 이용하여 데이터를 보호하고, 코드의 중복을 방지한다.  

등이 있다.
### 상속
java에는 상속이라는 개념이 있다. 자식 클래스가 부모 클래스를 상속하면 부모가 가지고 있는 메소드를 모두 사용할 수 있다.  
또한 부모 클래스의 메소드를 오버라이드 하면 더욱 향상시켜 사용할 수도 있다.  
